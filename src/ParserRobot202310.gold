using gold.**

toSet(C) :=  {x|  x in C}

///====   mini Parser===

function createParser(A):IPushdownAutomaton begin
	Q:= (0‥27)
	Σ:= toSet(A) ∪ {' ', '\n'}
	Γ:= {'1'}
	q₀:= 0
	F:= {11,13,14,15,16,21,23,24}
	M:=GPushdownAutomaton(Q,Σ,Γ,q₀,F)
	SkipChars := {' ', '\n'}   // this will only  be used when testing only the parser as the lexer removes  SkipChars
	
	// Start
	
	M.delta(0,1,"R").ignore() // ROBOT_R
	
	M.delta(1,2,"Vv").ignore() // ROBOT_R -> VARS
	M.delta(2,3,",").ignore()
	M.delta(3,3,"v,").ignore()
	M.delta(3,2,"v").ignore()
	
	M.delta(2,4,"P").ignore() // VARS -> PROCS
	M.delta(2,10,"[").ignore() // VARS -> BLOCK
	
	M.delta(1,4,"P").ignore() // ROBOT_R -> PROCS
	M.delta(4,5,"v[|").ignore()
	
	M.delta(5,6,"v").ignore()
	M.delta(6,8,"|").ignore()
	M.delta(6,7,",").ignore()
	M.delta(7,7,"v,").ignore()
	M.delta(7,5,"v").ignore()
	
	M.delta(5,8,"|").ignore()
	M.delta(8,9,"]").ignore()
	M.delta(9,10,"[").ignore() // PROCS -> BLOCK
	
	M.delta(1,10,"[").ignore() // ROBOT_R -> BLOCK
	M.delta(10,11,"]").ignore()
	
	// Commands
	
	M.delta(0,12,λ).ignore() // Out
	
	M.delta(12,13,"a:#,v").ignore() //  assignTo: n , name
	
	M.delta(12,13,"g:v,v").ignore() //  goTo: x, y
	M.delta(12,13,"g:#,v").ignore() 
	M.delta(12,13,"g:v,#").ignore() 
	M.delta(12,13,"g:#,#").ignore()
	
	M.delta(12,13,"m:#").ignore() // move: n
	M.delta(12,13,"m:v").ignore()
	
	M.delta(12,13,"t:L").ignore() // turn: D
	M.delta(12,13,"t:U").ignore()
	
	M.delta(12,13,"f:O").ignore() // face: O
	
	M.delta(12,13,"p:#,X").ignore() //  put: n , X; pick: n , X
	M.delta(12,13,"p:v,X").ignore() 
	
	M.delta(12,13, "o:#,L").ignore() // moveToThe: n, D; jumpToThe: n, D  
	M.delta(12,13, "o:#,c").ignore()
	M.delta(12,13, "o:v,L").ignore()
	M.delta(12,13, "o:v,c").ignore()
	
	M.delta(12,13, "i:#,O").ignore() // moveInDir: n, O; jumpInDir: n, O
	M.delta(12,13, "i:v,O").ignore()
	
	M.delta(12,13, "n:").ignore() // nop:
	
	M.delta(13,12,';').ignore() // Out
	
	// Procedure call
	
	M.delta(12,14,"v:").ignore()
	M.delta(14,15,"#").ignore()
	M.delta(14,15,"v").ignore()
	M.delta(15,12,';').ignore()
	
	M.delta(15,16,",").ignore()
	M.delta(16,16,"v,").ignore()
	M.delta(16,16,"#,").ignore()
	
	M.delta(16,14,"v").ignore()
	M.delta(16,14,"#").ignore()
	M.delta(14,12,';').ignore() // Out
	
	// Conditions
	
	M.delta(17,18, "c:O").ignore() // facing: O
	
	M.delta(17,18,"u:#,X").ignore() //  canPut: n , X;  canPick: n , X
	M.delta(17,18,"u:v,X").ignore() 
	
	M.delta(17,18,"r:#,O").ignore() // canMoveInDir: n, O; canJumpInDir: n, O 
	M.delta(17,18,"r:v,O").ignore()
	
	M.delta(17,18,"h:#,L").ignore() // canMoveToThe: n, D; canJumpToThe: n, D 
	M.delta(17,18,"h:#,c").ignore()
	M.delta(17,18,"h:v,L").ignore()
	M.delta(17,18,"h:v,c").ignore()
	
	M.delta(17,17, "!:").ignore() // not:
	
	// Control Structure
	
	M.delta(12,19,"I").ignore() // If: con then: [ins] else: [ins]
	M.delta(19,17,":").ignore()
	M.delta(18,20,"T:").ignore()
	M.delta(18,21,"E:").ignore()
	
	M.delta(12,22,"W").ignore() // while: con do: [ins]
	M.delta(22,17,":").ignore()
	M.delta(18,23,"D:").ignore()
	
	M.delta(12,24,"A:#").ignore() // repeat: n [ins]
	M.delta(12,24,"A:v").ignore()

	 for each q in Q do
	 	for each s in SkipChars do
	 	   M.delta(q,q,λ+s).ignore()
	 end
	 end

	return M
end

